
/**
 * 使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，
 *
 * 定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。
 * 幸好 JavaScript 引擎够聪明，能避免这个问题。当使用 setInterval() 时，仅当没有该定时器的任何其他代码实例时，
 * 才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。
 *
 * 这种重复定时器的规则有两个问题：
 * 1，某些间隔会被跳过。
 * 当该定时器代码还未执行完毕时，不会再次添加。
 * 2，多个定时器的代码执行之间的间隔可能会比预期的小。
 * 当该定时器代码刚执行完毕后，恰好间隔时间到，再次添加定时器代码并立即执行。
 */

// 为了避免 setInterval() 重复定时器的这2个缺点，可以使用链式 setTimeout() 调用。

var interval = 1000;

/**
 * 每次函数执行的时候都会创建一个新的定时器。第二个 setTimeout() 调用使用了
 * arguments.callee 来获取对当前执行的函数的引用，并为其设置另外一个定时器。
 * 这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。
 * 而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。
 * 这个模式主要用于重复定时器。JavaScript 动画中使用这个模式很常见。
 */
setTimeout(function () {
    // do something
    console.log(new Date());
    setTimeout(arguments.callee, interval);
}, interval);